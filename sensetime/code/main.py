# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16a-xAiALFeW-tV4PErULVWQsr6f3TkWm
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import math
from vcam import vcam, meshGen

paths = ["/content/WhatsApp Image 2024-06-23 at 3.32.09 PM (1).jpeg","/content/WhatsApp Image 2024-06-23 at 3.32.10 PM (1).jpeg"]
for mode in range(8):
    for i, path in enumerate(paths):
        # Reading the input image
        img = cv2.imread(path)
        img = cv2.resize(img, (300, 300))
        H, W = img.shape[:2]

        # Creating the virtual camera object
        c1 = vcam(H=H, W=W)

        # Creating the surface object
        plane = meshGen(H, W)

        # Apply the distortion/transformation
        # We generate a mirror where for each 3D point, its Z coordinate is defined as Z = F(X,Y)

        if mode == 0:
            plane.Z += 20*np.exp(-0.5*((plane.X*1.0/plane.W)/0.1)**2)/(0.1*np.sqrt(2*np.pi))
        #elif mode == 1:
          #  plane.Z += 20*np.exp(-0.5*((plane.Y*1.0/plane.H)/0.1)**2)/(0.1*np.sqrt(2*np.pi))
        #elif mode == 2:
           # plane.Z -= 10*np.exp(-0.5*((plane.X*1.0/plane.W)/0.1)**2)/(0.1*np.sqrt(2*np.pi))
        #elif mode == 3:
           # plane.Z -= 10*np.exp(-0.5*((plane.Y*1.0/plane.W)/0.1)**2)/(0.1*np.sqrt(2*np.pi))
        elif mode == 4:
            plane.Z += 20*np.sin(2*np.pi*((plane.X-plane.W/4.0)/plane.W)) + 20*np.sin(2*np.pi*((plane.Y-plane.H/4.0)/plane.H))
        elif mode == 5:
            plane.Z -= 20*np.sin(2*np.pi*((plane.X-plane.W/4.0)/plane.W)) - 20*np.sin(2*np.pi*((plane.Y-plane.H/4.0)/plane.H))
        elif mode == 6:
            plane.Z += 100*np.sqrt((plane.X*1.0/plane.W)*2+(plane.Y*1.0/plane.H)*2)
        elif mode == 7:
            plane.Z -= 100*np.sqrt((plane.X*1.0/plane.W)*2+(plane.Y*1.0/plane.H)*2)
        else:
            print("Wrong mode selected")
            exit(-1)

        # Generating the output
        output = cv2.remap(img, map_x, map_y, interpolation=cv2.INTER_LINEAR)
        output = cv2.flip(output, 1)

        # Display the images using Matplotlib
        fig, ax = plt.subplots(1, 2, figsize=(12, 6))
        ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        ax[0].set_title("Input Image")
        ax[1].imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB))
        ax[1].set_title("Output Image")
        plt.show()

        # Uncomment the following line to save the outputs
        # cv2.imwrite("Mirror-effect-%d-image-%d.jpg"%(mode+1,i+1),np.hstack((img,np.zeros((H,2,3),dtype=np.uint8),output)))

import cv2
import matplotlib.pyplot as plt
import numpy as np
import math
!pip3 install vcam
from vcam import vcam, meshGen

paths = ["/content/WhatsApp Image 2024-06-23 at 3.32.09 PM (1).jpeg", "/content/WhatsApp Image 2024-06-23 at 3.32.10 PM (1).jpeg"]
for mode in range(8):
    for i, path in enumerate(paths):
        # Reading the input image
        img = cv2.imread(path)
        img = cv2.resize(img, (300, 300))
        H, W = img.shape[:2]

        # Creating the virtual camera object
        c1 = vcam(H=H, W=W)

        # Creating the surface object
        plane = meshGen(H, W)

        # Apply the distortion/transformation
        if mode == 0:
            plane.Z += 20*np.exp(-0.5*((plane.X*1.0/plane.W)/0.1)**2)/(0.1*np.sqrt(2*np.pi))
        elif mode == 4:
            plane.Z += 20*np.sin(2*np.pi*((plane.X-plane.W/4.0)/plane.W)) + 20*np.sin(2*np.pi*((plane.Y-plane.H/4.0)/plane.H))
        elif mode == 5:
            plane.Z -= 20*np.sin(2*np.pi*((plane.X-plane.W/4.0)/plane.W)) - 20*np.sin(2*np.pi*((plane.Y-plane.H/4.0)/plane.H))
        elif mode == 6:
            plane.Z += 100*np.sqrt((plane.X*1.0/plane.W)*2+(plane.Y*1.0/plane.H)*2)
        elif mode == 7:
            plane.Z -= 100*np.sqrt((plane.X*1.0/plane.W)*2+(plane.Y*1.0/plane.H)*2)
        else:
            print("Wrong mode selected")
            exit(-1)

        # Generating the output
        map_x, map_y = c1.get_mapx_mapy()
        output = cv2.remap(img, map_x, map_y, interpolation=cv2.INTER_LINEAR)
        output = cv2.flip(output, 1)

        # Display the images using Matplotlib
        fig, ax = plt.subplots(1, 2, figsize=(12, 6))
        ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        ax[0].set_title("Input Image")
        ax[1].imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB))
        ax[1].set_title("Output Image")
        plt.show()

        # Save the output images
        cv2.imwrite(f"Mirror-effect-{mode+1}-image-{i+1}.jpg", output)